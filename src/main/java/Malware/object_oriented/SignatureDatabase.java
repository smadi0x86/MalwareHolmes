package Malware.object_oriented;

import java.io.BufferedReader; // Import the BufferedReader class to read the content of the file.
import java.io.FileNotFoundException; // Import the FileNotFoundException class to handle FileNotFoundException exceptions.
import java.io.FileReader; // Import the FileReader class to read the content of the file.
import java.io.IOException; // Import the IOException class to handle I/O exceptions.
import java.util.HashMap; // Import the HashMap class to store the mappings of hashes to malware names.

public class SignatureDatabase {

    /*
     * This will use a hashmap to store the hashes of known malware from the malware_hashes.csv file.
     * It provides methods to load the signatures from the malware_hashes.csv and retrieve the stored hashes for comparison.
     * The SignatureDatabase class encapsulates the collection of signatures as a private data member and provides methods to load and retrieve the signatures.
     
     ! Pseudo code:
        ? 0. Import all necessary libraries.
        ? 1. Declare a private HashMap<String, String> named signatures to store the mappings of hashes to malware names. The key of the map will be the hash, and the value will be the malware name.
        ? 2. Implement a constructor for the SignatureDatabase class.
        ? 3. Within the constructor, initialize the signatures HashMap so that it is ready to store the signatures.
        ? 4. Implement a method called loadSignaturesFromFile that takes a file path or name as a parameter. This method will load the malware signatures from the specified CSV file into the signatures HashMap.
        ? 5. Read the CSV file line by line.
        ? 6. For each line, split the line into two parts: 
            1. The Hash value
            2. The Malware name
    
        ? 7. Add the hash and malware name as a key-value pair in the signatures HashMap.
        ? 8. Close the file after reading all the lines.
        ? 9. Implement a method called getMalwareNameByHash that takes a hash as a parameter and returns the associated malware name from the signatures HashMap.
        ? 10. Retrieve the malware name from the signatures HashMap using the provided hash as the key.
        ? 11. If the hash exists in the signatures HashMap, return the associated malware name else return null.
    
        * References:
        *    - https://www.baeldung.com/java-read-lines-large-file
        *    - https://www.baeldung.com/java-string-split
        *    - https://www.baeldung.com/java-hashmap
        *    - https://www.geeksforgeeks.org/hashmap-in-java/
        *    - https://www.baeldung.com/java-hashmap-get-vs-containskey
    */

    private HashMap<String, String> signatures; // ? That doesn't mean that the HashMap is a signature, it means that the SignatureDatabase class has a HashMap of signatures.

    // Implement a constructor for the SignatureDatabase class to initialize the signatures HashMap 
    // Without a constructor we won't be able to use the SignatureDatabase class in the main method.
    public SignatureDatabase() {
        signatures = new HashMap<>();
    }

    // ! The throwed exceptions are handled in the main method.
    public void loadSignaturesFromFile(String filePath) throws IOException, FileNotFoundException {

        BufferedReader reader = new BufferedReader(new FileReader(filePath)); // ? read the malware_hashes.csv file.
        {

            String line; // ? To read the CSV file line by line.

            // ? while the reader.readLine() method returns a non-null value which means there are still lines to read.
            while ((line = reader.readLine()) != null) {

                String[] parts = line.split(","); // split the line into two parts: the hash value and the malware name separated by a comma.

                // if the line contains two parts, add the hash and malware name as a key-value pair in the signatures HashMap.
                if (parts.length == 2) {

                    String hash = parts[0].trim(); // trim the hash value to remove any leading or trailing whitespace.
                    String malwareName = parts[1].trim(); // trim the malware name to remove any leading or trailing whitespace.
                    signatures.put(hash, malwareName); // add the hash and malware name as a key-value pair in the signatures HashMap.
                }
            }
        }
        reader.close();
    }

    public String getMalwareNameByHash(String hash) {

        // if the hash exists in the signatures HashMap, return the associated malware name to be used in the signature identification process.
        if (signatures.containsKey(hash)) {
            return signatures.get(hash); // this will return the malware name. hash is the key and the malware name is the value. its not .get(value) because we want to get the malware name by the hash.
        } else {
            return null;
        }
    }
}

// ! Done