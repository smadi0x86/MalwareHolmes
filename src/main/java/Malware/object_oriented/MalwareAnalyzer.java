package Malware.object_oriented;

import java.io.File; // Import the File class to create a file object from the input file path.
import java.io.FileInputStream; // Import the FileInputStream class to read the input file.
import java.io.IOException; // Import the IOException class to handle I/O exceptions.
import java.security.MessageDigest; // Import the MessageDigest class to calculate the hash value of the input file.
import java.security.NoSuchAlgorithmException; // Import the NoSuchAlgorithmException class to handle NoSuchAlgorithmException exceptions.

public class MalwareAnalyzer {

    /*
     * This class is responsible for analyzing an input file using an object-oriented paradigm. 
     * It calculates the hash value of the file and checks if it matches any known malware signature.
     * The MalwareAnalyzer class encapsulates the analysis logic and provides a public method to perform the analysis.
    */

    // Represents the SignatureIdentifier object used for signature comparison, protected means that it can be accessed by the child classes of the MalwareAnalyzer class.
    protected SignatureIdentifier signatureIdentifier;

    // ! Constructor for the MalwareAnalyzer class to initialize the signatureIdentifier object so that it is ready to be used.
    public MalwareAnalyzer(SignatureIdentifier signatureIdentifier) {
        this.signatureIdentifier = signatureIdentifier; //  this.signatureIdentifier refers to the SignatureIdentifier object of the MalwareAnalyzer class not the SignatureIdentifier class.
    }

    public String analyzeFile(String filePath) throws IOException {
        /*
         * Analyzes the input file by calculating its hash value and comparing it with known malware signatures.
         * 
         * Parameters:
         *  - filePath: The path or file object of the input file.
         * 
         * Returns:
         *  - The calculated hash value of the file.
         * 
         ! Throws:
         ?  - IOException: If an I/O error occurs during file reading to the calculateHash method.
         * 
         ! Catches:
         ? - IOException is catched in the main method.
         */

        String fileHash; // This variable will store the calculated hash value of the input file.

        try {
            fileHash = calculateHash(filePath); // Calculate the hash value of the input file from the calculateHash method.

            signatureIdentifier.compareHash(fileHash); // Compare the calculated hash value with known malware signatures.

            return fileHash; // Return the calculated hash value.

        } catch (NoSuchAlgorithmException e) {
            System.out.println("Error catched: " + e.getMessage()); // Print the error message.
            e.printStackTrace(); // The stack strace is the list of method calls that lead to the exception and its printed to the console.
        } catch (Exception e) {
            System.out.println("Error catched: " + e.getMessage()); // Print the error message.
            e.printStackTrace(); // The stack strace is the list of method calls that lead to the exception and its printed to the console.
        }

        return null;
    }

    // ! This will receive IOexception from the child class then throw it to main.
    public String calculateHash(String filePath) throws IOException, NoSuchAlgorithmException {

        /*
         * Calculates the hash value of the input file.
         * 
         * Parameters:
         *  - filePath: The path or file object of the input file.
         * 
         * Returns:
         *  - The calculated hash value as a hexadecimal string.
         * 
         ! Throws:
         ?  - IOException: If an I/O error occurs during file reading.
         ?  - NoSuchAlgorithmException: If the hashing algorithm specified is not available.
         * 
         ! Catches:
         ? - I/O exception is catched in the main method, which was sent from the child class methods.
         ? - NoSuchAlgorithmException is catched in the analyzeFile method.
         * 
         * References:
         * - https://www.baeldung.com/java-md5
         * - https://www.geeksforgeeks.org/md5-hash-in-java/
         * - https://www.tutorialspoint.com/java_cryptography/java_cryptography_message_digest.htm
         * - https://www.tutorialspoint.com/java/io/fileinputstream_read_byte.htm
         * - https://www.tutorialspoint.com/java/io/fileinputstream_available.htm
         */

        File file = new File(filePath); // Create a file object from the input file path.

        FileInputStream fis = new FileInputStream(file); // Create a FileInputStream object to read the file.

        MessageDigest digest = MessageDigest.getInstance("MD5"); // Create a MessageDigest object to calculate the hash value of the file.

        byte[] buffer = new byte[8192]; // Create a buffer to read the file in chunks, 8192 is randomly chosen because it is a power of 2 (Its a good practice to use powers of 2 when working with buffers)

        int bytesRead; // This variable will store the number of bytes read from the file.

        // while there are still bytes to read from the file, read them and update the digest object, -1 is EOF.
        while ((bytesRead = fis.read(buffer)) != -1) {
            digest.update(buffer, 0, bytesRead); // Update the digest object with the bytes read from the file.
        }

        byte[] hashBytes = digest.digest(); // Calculate the hash value of the file, digest.digest() returns a byte array.

        StringBuilder hashBuilder = new StringBuilder(); // Create a StringBuilder object to store the hash value as a hexadecimal string.

        // for each byte in the hashBytes array, convert it to a hexadecimal string and append it to the hashBuilder object.
        // Note: %02x means that the byte will be converted to a hexadecimal string with a length of 2 (2 characters for each byte) or 0 padded if the length is less than 2.
        // reference: https://www.baeldung.com/java-printstream-printf
        for (byte b : hashBytes) {
            hashBuilder.append(String.format("%02x", b));
        }

        fis.close(); // Close the FileInputStream object.

        return hashBuilder.toString(); // Return the hash value as a hexadecimal string, toString() converts the StringBuilder object to a String object.

        // ! Note: We convert byte array which is the hash value to a hexadecimal string because it is easier to compare strings than byte arrays (byte arrays are not human readable).
    }
}