#include "Malware_logic_peAnalysis_NativeWrapperPE.h"
#include <jni.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <unistd.h>

JNIEXPORT jint JNICALL Java_Malware_logic_peAnalysis_NativeWrapperPE_analyzePE(JNIEnv *env, jobject obj, jstring filePath)
{
    const char *nativeString = (*env)->GetStringUTFChars(env, filePath, 0);

    // Get the filename from the path
    const char *filename = strrchr(nativeString, '\\');
    if (filename == NULL)
    {
        filename = nativeString;
    }
    else
    {
        filename++;
    }

    // Remove the extension from the filename
    char *filenameWithoutExt = strdup(filename);
    char *lastdot = strrchr(filenameWithoutExt, '.');
    if (lastdot != NULL)
    {
        *lastdot = '\0';
    }

    // Create the logfile name
    char logfile[255];
    sprintf(logfile, "%sPELog.txt", filenameWithoutExt);

    // Create a duplicate of the stdout file descriptor before we redirect it
    int stdout_dupfd = dup(fileno(stdout));
    if (stdout_dupfd == -1)
    {
        perror("Failed to duplicate stdout file descriptor");
        (*env)->ReleaseStringUTFChars(env, filePath, nativeString);
        return -1; // Return an error code
    }

    // Redirect stdout to the logfile
    FILE *logfp = freopen(logfile, "w", stdout);
    if (logfp == NULL)
    {
        perror("Failed to redirect stdout to file");
        (*env)->ReleaseStringUTFChars(env, filePath, nativeString);
        return -1; // Return an error code
    }

    // Open the file in binary mode
    FILE *file = fopen(nativeString, "rb");

    // Check if the file was opened successfully
    if (file == NULL)
    {
        perror("Failed to open file");
        (*env)->ReleaseStringUTFChars(env, filePath, nativeString);
        return -1; // Return an error code
    }

    // Get the path to the DLL file (assuming the DLL is in the same directory as the C code)
    char dllPath[MAX_PATH];
    GetModuleFileName(GetModuleHandle("peAnalysis.dll"), dllPath, MAX_PATH);
    char *lastBackslash = strrchr(dllPath, '\\');
    if (lastBackslash != NULL)
    {
        *lastBackslash = '\0';
    }

    // Construct the path to FileDump.exe relative to the DLL file
    char fileDumpPath[MAX_PATH];
    sprintf(fileDumpPath, "%s\\FileDump.exe", dllPath);

    // Execute FileDump.exe
    char *command = malloc(strlen(fileDumpPath) + strlen(nativeString) + 5); // Add 5 for the extra quotes and spaces
    sprintf(command, "\"%s\" \"%s\"", fileDumpPath, nativeString);           // Enclose both paths with quotes

    // CreateProcess() variables
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&pi, sizeof(pi));

    // Start the child process.
    if (!CreateProcess(NULL,    // No module name (use command line)
                       command, // Command line
                       NULL,    // Process handle not inheritable
                       NULL,    // Thread handle not inheritable
                       FALSE,   // Set handle inheritance to FALSE
                       0,       // No creation flags
                       NULL,    // Use parent's environment block
                       NULL,    // Use parent's starting directory
                       &si,     // Pointer to STARTUPINFO structure
                       &pi)     // Pointer to PROCESS_INFORMATION structure
    )
    {
        printf("CreateProcess failed (%d).\n", GetLastError());
        free(command);
        fclose(file);
        (*env)->ReleaseStringUTFChars(env, filePath, nativeString);
        return -1;
    }

    // Wait until the child process exits.
    WaitForSingleObject(pi.hProcess, INFINITE);

    // Close process and thread handles.
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    free(command);
    free(filenameWithoutExt);

    fclose(file); // Close the file when you're done with it
    (*env)->ReleaseStringUTFChars(env, filePath, nativeString);

    // Redirect stdout back to the original stdout using dup2
    fflush(stdout);
    dup2(stdout_dupfd, fileno(stdout));
    close(stdout_dupfd);

    return 0;
}
