package Malware.logic;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.nio.file.*;
import java.util.function.Predicate;

import Malware.logic.peAnalysis.NativeWrapperPE;
import Malware.logic.staticAnalysis.NativeWrapper;

public class DirectoryMonitorService implements Runnable {

    private final Path dir;
    private final MalwareAnalyzer malwareAnalyzer;
    private final Predicate<Path> filter;

    public DirectoryMonitorService(Path dir, MalwareAnalyzer malwareAnalyzer, Predicate<Path> filter) {
        this.dir = dir;
        this.malwareAnalyzer = malwareAnalyzer;
        this.filter = filter;

        try {
            System.out.println("[+] MalwareHolmes is running, press Enter to stop it.");
            System.out.println("[!] MalwareHolmes watching the folder: " + dir + "\n");
            // Create a new PrintStream that writes to a file and also forwards the output to the original System.out
            PrintStream out = new PrintStream(new FileOutputStream("MalwareHolmesLogs.txt", true), true);
            PrintStream err = new PrintStream(new FileOutputStream("MalwareHolmesErrorLogs.txt", true), true);
            System.setOut(out);
            System.setErr(err);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void run() {
        try (WatchService watcher = FileSystems.getDefault().newWatchService()) {
            dir.register(watcher, StandardWatchEventKinds.ENTRY_CREATE);

            System.out.println("[!] MalwareHolmes watching the folder: " + dir + "\n");

            while (true) {
                WatchKey key;
                try {
                    key = watcher.take();
                } catch (InterruptedException ex) {
                    return;
                }

                for (WatchEvent<?> event : key.pollEvents()) {
                    WatchEvent.Kind<?> kind = event.kind();

                    @SuppressWarnings("unchecked")
                    WatchEvent<Path> ev = (WatchEvent<Path>) event;
                    Path fileName = ev.context();

                    if (kind == StandardWatchEventKinds.ENTRY_CREATE && filter.test(fileName)) {

                        // A new file has been created
                        System.out.println("\n");
                        System.out.println("[+] New file: " + fileName + " is created in the directory.\n");

                        // Run malware analysis code on the new file
                        analyzeFile(dir.resolve(fileName).toString());
                    }
                }

                boolean valid = key.reset();
                if (!valid) {
                    break;
                }
            }
        } catch (IOException e) {
            System.err.println("Exception occurred while monitoring directory: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private void analyzeFile(String filePath) {
        try {
            // Check if the file is a PE/exe
            boolean isPEFile = isPEFile(filePath);

            // Start hash-based analysis
            String analysisResult = malwareAnalyzer.analyzeFile(filePath);
            System.out.println("Analysis hash result for your file: " + analysisResult + "\n");

            // Start static analysis if not a PE file
            if (!isPEFile) {
                NativeWrapper nativeWrapper = new NativeWrapper();
                nativeWrapper.analyze(filePath);
            } else {
                System.out.println("PE file detected! Dumping its information...");

                // start PE analysis
                NativeWrapperPE nativeWrapperPE = new NativeWrapperPE();

                // Dump PE meta data
                nativeWrapperPE.pemetaData(filePath);

                // Dump PE information
                nativeWrapperPE.analyzePE(filePath);

                System.out.println("Dumped PE successfully!\n");
                System.out.println(
                        "The PE dump log is saved to current directory: " + System.getProperty("user.dir") + "\n");

                // Start Automated PE analysis

                // Extract the file name from the filePath
                Path path = Paths.get(filePath);
                String fileBaseName = path.getFileName().toString();

                // Remove the extension
                String filenameWithoutExt = fileBaseName.contains(".")
                        ? fileBaseName.substring(0, fileBaseName.lastIndexOf('.'))
                        : fileBaseName;

                // Build the paths to the original and analysis log files
                String peLogFilePath = System.getProperty("user.dir") + "\\" + filenameWithoutExt + "PELog.txt";
                String analysisLogFilePath = System.getProperty("user.dir") + "\\" + filenameWithoutExt
                        + "AnalysisPELog.txt";

                // Analyze the log file and write the analysis to a new file
                LogAnalyzer.analyzeLogFile(peLogFilePath, analysisLogFilePath);

                System.out.println("Analysis of dump log is saved to: " + analysisLogFilePath);
            }
        } catch (IOException e) {
            System.err.println("Exception occurred during file analysis: " + e.getMessage());
            e.printStackTrace();
        } catch (Exception e) {
            System.err.println("Unexpected exception occurred: " + e.getMessage());
            e.printStackTrace();
        }
    }

    // Check if the file is a PE/exe to run dynamic analysis
    private boolean isPEFile(String filePath) {
        try {
            byte[] fileBytes = Files.readAllBytes(Paths.get(filePath));

            // Add a check to ensure the fileBytes array is not empty
            if (fileBytes.length > 1 && fileBytes[0] == 'M' && fileBytes[1] == 'Z') {
                return true;
            }
        } catch (IOException e) {
            System.err.println("Exception occurred while reading file: " + e.getMessage());
            e.printStackTrace();
        }
        return false;
    }
}