package Malware.logic;

import java.nio.file.*;
import java.io.*;
import java.util.stream.*;
import java.util.Arrays;
import java.util.List;
import java.util.HashMap;

public class LogAnalyzer {
    // Expected maximum sizes for .text, .data and .rdata sections
    private static final int EXPECTED_MAX_TEXT_SIZE = 0x10000; // 65,536 in decimal
    private static final int EXPECTED_MAX_DATA_SIZE = 0x8000; // 32,768 in decimal
    private static final int EXPECTED_MAX_RDATA_SIZE = 0x4000; // 16,384 in decimal

    // List of potentially malicious functions
    private static final List<String> SUSPICIOUS_FUNCTIONS = Arrays.asList(
            "CloseHandle", "CreateRemoteThreadEx", "DeleteCriticalSection",
            "EnterCriticalSection", "GetLastError", "GetStartupInfoA",
            "InitializeCriticalSection", "IsDBCSLeadByteEx", "LeaveCriticalSection",
            "MultiByteToWideChar", "OpenProcess", "SetUnhandledExceptionFilter",
            "Sleep", "TlsGetValue", "VirtualAllocEx", "VirtualProtect",
            "VirtualQuery", "WaitForSingleObject", "WideCharToMultiByte",
            "WriteProcessMemory");
    // TODO: Add more functions

    // List of suspicious DLLs
    private static final List<String> SUSPICIOUS_DLLS = Arrays.asList("KERNEL32.dll", "msvcrt.dll");

    // HashMap to track the occurrence of suspicious functions
    private static HashMap<String, Boolean> functionTracker = new HashMap<>();

    // List of function combinations that are indicative of malware
    private static final List<List<String>> SUSPICIOUS_FUNCTION_COMBINATIONS = Arrays.asList(
            Arrays.asList("CreateRemoteThreadEx", "VirtualAllocEx"),
            Arrays.asList("VirtualAllocEx", "WriteProcessMemory"),
            Arrays.asList("VirtualAllocEx", "VirtualProtect"));
    // TODO: Add more combinations

    public static void analyzeLogFile(String filePath, String analysisFilePath) {
        try (Stream<String> lines = Files.lines(Paths.get(filePath));
                BufferedWriter writer = Files.newBufferedWriter(Paths.get(analysisFilePath))) {

            lines.forEach(line -> {
                if (lineHasIdentifiableKey(line)) {
                    String analysis = analyzeLine(line);
                    try {
                        writer.write(analysis);
                        writer.newLine();
                    } catch (IOException e) {
                        System.err.println("Failed to write analysis to log: " + e.getMessage());
                    }
                }

                // Check for suspicious functions and DLLs
                if (isSuspiciousFunction(line) || isSuspiciousDll(line)) {
                    try {
                        writer.write(line
                                + " -- Warning: Contains potentially malicious function or DLL. This might be a sign of malware.");
                        writer.newLine();
                    } catch (IOException e) {
                        System.err.println("Failed to write analysis to log: " + e.getMessage());
                    }
                    trackSuspiciousFunctions(line);
                }
            });

            // Check for function combinations after file analysis
            checkForSuspiciousFunctionCombinations(writer);

        } catch (IOException e) {
            System.err.println("Failed to analyze log file: " + e.getMessage());
        }
    }

    private static void trackSuspiciousFunctions(String line) {
        for (String func : SUSPICIOUS_FUNCTIONS) {
            if (line.contains(func)) {
                functionTracker.put(func, true);
                break;
            }
        }
    }

    private static boolean isSuspiciousFunction(String line) {
        return SUSPICIOUS_FUNCTIONS.stream().anyMatch(line::contains);
    }

    private static boolean isSuspiciousDll(String line) {
        return SUSPICIOUS_DLLS.stream().anyMatch(line::contains);
    }

    private static void checkForSuspiciousFunctionCombinations(BufferedWriter writer) {
        for (List<String> combination : SUSPICIOUS_FUNCTION_COMBINATIONS) {
            boolean isAllPresent = combination.stream().allMatch(func -> functionTracker.getOrDefault(func, false));
            if (isAllPresent) {
                try {
                    writer.write(
                            String.join(" and ", combination) + " are used together. This might be a sign of malware.");
                    writer.newLine();
                } catch (IOException e) {
                    System.err.println("Failed to write analysis to log: " + e.getMessage());
                }
            }
        }
    }

    private static boolean lineHasIdentifiableKey(String line) {
        String key = line.split("\\s+")[0].trim();
        return key.equals("Machine") || key.equals("NumberOfSections") || key.equals("Characteristics") ||
                key.equals("SizeOfCode") || key.equals("MajorLinkerVersion") || key.equals("MinorLinkerVersion") ||
                key.equals("ImportDirectory (RVA)") || key.equals("ImportDirectory (Size)") ||
                key.equals("BaseReloc Directory (RVA)") || key.equals("IAT Directory (RVA)") ||
                key.equals("IAT Directory (Size)") || key.equals("Name") || key.equals("VirtualSize");
    }

    private static String analyzeLine(String line) {
        String[] parts = line.split("\\s+");
        String key = parts[0].trim();
        String value = parts.length > 1 ? parts[1].trim() : "";

        switch (key) {
            case "Machine":
                return value.equals("8664") ? line + " -- Note: Machine code is standard."
                        : line + " -- Warning: Unusual machine code. Might be a sign of malware.";
            case "NumberOfSections":
                int numberOfSections = Integer.parseInt(value, 16);
                return numberOfSections > 10
                        ? line + " -- Warning: Unusually high number of sections. Might be a sign of malware."
                        : line + " -- Note: Number of sections is within normal range.";
            case "SizeOfCode":
                int sizeOfCode = Integer.parseInt(value, 16);
                return sizeOfCode > 100000
                        ? line + " -- Warning: Unusually large code size. Might be a sign of malware."
                        : line + " -- Note: Code size is within normal range.";
            case "MajorLinkerVersion":
            case "MinorLinkerVersion":
                int version = Integer.parseInt(value, 16);
                return version < 2 ? line + " -- Warning: Old linker version. Might be a sign of malware."
                        : line + " -- Note: Linker version is up-to-date.";
            case "ImportDirectory (RVA)":
            case "ImportDirectory (Size)":
                int importDirSize = Integer.parseInt(value, 16);
                return importDirSize > 10000
                        ? line + " -- Warning: Unusually large Import Directory. Might be a sign of malware."
                        : line + " -- Note: Import Directory size is within normal range.";
            case "BaseReloc Directory (RVA)":
                return value.equals("00000000")
                        ? line + " -- Warning: No base relocation information found. Might be a sign of malware."
                        : line + " -- Note: Base relocation information is present.";
            case ".text":
                int textSize = Integer.parseInt(value, 16);
                return textSize > EXPECTED_MAX_TEXT_SIZE
                        ? line + " -- Warning: Unusually large .text section size. Might be a sign of malware."
                        : line + " -- Note: .text section size is within normal range.";
            case ".data":
                int dataSize = Integer.parseInt(value, 16);
                return dataSize > EXPECTED_MAX_DATA_SIZE
                        ? line + " -- Warning: Unusually large .data section size. Might be a sign of malware."
                        : line + " -- Note: .data section size is within normal range.";
            case ".rdata":
                int rdataSize = Integer.parseInt(value, 16);
                return rdataSize > EXPECTED_MAX_RDATA_SIZE
                        ? line + " -- Warning: Unusually large .rdata section size. Might be a sign of malware."
                        : line + " -- Note: .rdata section size is within normal range.";

            default:
                return line;
        }
    }
}
